leetcode、poj、zoj

算法题可以快速判断候选人的代码和思维能力:)
面试题的集中地，认可度高！

算法和数据结构

如何使用 leetcode

1. 刷题程度 ：AC

1. 勉强正确
2. 快速正确、完美应对、包括可能边角数据
3. 快速最优正确(时间复杂度)
4. 快速最优解，代码风格优美，变量名含义清晰，过程清楚明白

leetcode 题目 1000题，2个月左右？不需要、不同的人刷题策略（越往前、越经典）专题 61% 30%

### 刷题过程规划

1. 刚接触算法题目：分专题掌握知识点
2. 已熟悉相关算法：巩固知识脉络和手感 (变量命名，易读性)
3. 对基本算法和题目非常熟练：接触高级算法和数据结构，提升应试能力

### 学习规划

1. 数据结构
2. 算法
3. 课后练习
4. 主动暂停和回放视频

### 小技巧和常见误区

1. 运行速度和时间复杂度：不用执着于优化常数
2. 关于空间复杂度：没特殊要求不用苛求
3. 关于原选择：建议：C++, 用python可能有坑 (复杂度正确，可能也会超时)
4. 如何确定最优解法，探索数据范围

### 算法复杂度

1. 算法复杂度的定义和计算

分为2个维度：时间复杂度、空间复杂度

以后复杂度就指 时间复杂度

### 时间复杂度

时间复杂度是否到了10^8, 基于循环的简介复杂度

### 算法复杂度

- 什么是算法复杂度？

算法复杂度一般分为2个维度：时间复杂度和空间复杂度；针对空间复杂度的问题，现在的我们很少去关心了，因为磁盘内存等变得越来越廉价，我们以后说的复杂度一般只针对 **时间复杂度**

### 如何计算复杂度

估算如下计算次数

- 第 **1** 题

    ```python
    # 只执行了 1 次 时间复杂度为 O(1)
    def func():
        a = 1
    ```


- 第 **2** 题
	```python
    # 执行了 10 次 , 有一层循环，时间复杂度为O(n) 
	def func():
		for i in range(10):
			a = 1	
	```

- 第 **3** 题
	```python
    # 执行了 10*10 = 100 次, 有两层循环，时间复杂度为O(n^2)
	def func():
		for i in range(10):
			for j in range(10):
				a = 1
	```

- 第 **4** 题
	```python
    # 执行了 10+ 9 + 8 + ... + 1 = 55 次
	def func():
		for i in range(10):
			for j in range(i, 10):
				a = 1
	```

- 第 **5** 题
	```python
    '''
    用变量代替执行次数, 执行了 n+ (n-1) + (n-2) + ... + 1 = n * ((n+1) / 2) 次
	化简后后：1/2 * n^2 + 1/2 * n
	时间复杂度为：O(1/2 * n^2 + 1/2 * n)
	由于我们一般只保留最高次的项，并且不保留系数，时间复杂度为：O(n^2)
    '''
	def func():
		n = 10
		for i in range(n):
			for j in range(i, n):
				a = 1
	```
	
	
- 第 **6** 题
	```python
    '''
    用变量代替执行次数, 执行了 2*(n+ (n-1) + (n-2) + ... + 1) = n * (n+1) 次
	化简后后：n^2 + n
	时间复杂度为：O(n^2 + n)
	
	由于我们一般只保留最高次的项，并且不保留系数，时间复杂度为：O(n^2)
	'''
    def func():
		n = 10
		for i in range(n):
			for j in range(i, n):
				a = 1
				b = 2
	```
	

- 7.比较5、6 两者时间复杂度相同，但是两者速度不同，不同之处是系数不同, 在n很大的情况下, 系数和非最高次项都是可以省略的

- 8.如果程序跑得太慢，有可能是一下两方面的原因：
	①、时间复杂度过大 ②、常数项过大

### 算法复杂度常数
1. 两个算法的时间复杂度均为O(n^2)，但也要区分跑几个n^2, 速度是完全不一样的
2. 系数和非最高此项均可视为常数
3. 复杂度与速度没有必然联系，常数项在中间起了很大作用
4. 如果n值越大，常数项的作用越小, 将n看成非常大，常数项便可以被忽略不计

### 常见的时间复杂度示例

1. 时间复杂度为: O(1) 也就是常数复杂度

```python
def func():
	a = 1
```

2. 空间复杂度为: O(N) 也就是线性复杂度 (通常特征是一层循环)

```python
def func():
	n = 10
	for i in range(n):
		a = 1

```

3. 多项式复杂度O(N^2) (通常特征是双层循环)

```python
def func():
	n = 10
	for i in range(n):
		for j in range(i, n):
			a = 1
```

4. 指数复杂度O(2^n)

```python
def func(n):
	if n <= 1: return n
	return func(n-1) + func(n-1)
```

5. 对数复杂度O(log(N))

```python
# 此项时间复杂度为以2为底的log(N) 即 log2(N)
def func(n):
	if n <= 1: return n
	return func(n // 2) + 1
```

6. 渐进复杂度O(N)

```python
def func(n):
	if n <= 1: return
	mid = n // 2
	for i in range(mid+1, n):
		a = 1
	func(mid)
```

f(n) = f(n/2) + n/2
f(n) = f(n/4) + n/4 + n/2
f(n) = f(n/8) + n/8 + n/4 + n/2
...

推导出：
f(n) = n/2 + n/4 + n/8 + ... <= n

7. 均摊复杂度O(N) 【此处可能有问题，待研究】

以下示例， n次操作，求时间复杂度

```python
a = []
def func(x):
	if x == 0:
		a.push(x)
	else:
		while a.size() > 0:
			a.pop()
```

步骤一、x = 0 时, 单次时间复杂度 O(1)、n次为 O(N)
步骤二、x != 0 时, 单次时间复杂度为 O(N)、n次为 O(N^2)

换一种思路：

每一次的操作步骤均不相同时，我们考虑总体次数就能想明白问题了
此处可能有问题，待研究